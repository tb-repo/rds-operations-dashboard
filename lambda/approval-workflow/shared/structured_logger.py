"""
Enhanced Structured Logging Utility

Generated by: claude-3.5-sonnet
Timestamp: 2025-12-03T00:00:00Z
Version: 2.0.0
Policy Version: v1.0.0
Traceability: REQ-5.1 → DESIGN-5.1 → TASK-4.1
Review Status: Pending
Risk Level: Level 2

Purpose: Provide enhanced structured JSON logging for all Lambda functions with
correlation IDs, metrics, context propagation, and consistent formatting for CloudWatch Logs.

Enhancements over v1.0:
- Improved correlation ID extraction from API Gateway events
- Context manager support for scoped logging
- Better integration with AWS X-Ray
- Enhanced sensitive data redaction patterns
- Performance metrics tracking
"""

import json
import logging
import os
import uuid
from datetime import datetime
from typing import Any, Dict, Optional, List
from functools import wraps
from contextlib import contextmanager

# Log level from environment variable
LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO').upper()


class StructuredLogger:
    """
    Enhanced structured JSON logger for Lambda functions.
    
    Features:
    - Automatic correlation ID extraction from API Gateway events
    - Context manager support for scoped logging
    - Sensitive data redaction
    - Performance metrics tracking
    - AWS X-Ray integration
    
    Usage:
        # Basic usage
        logger = StructuredLogger('discovery-service')
        logger.info('Discovery started', account_id='123456789012')
        
        # With Lambda context
        logger = StructuredLogger('discovery-service', lambda_context=context)
        
        # With API Gateway event (auto-extracts correlation ID)
        logger = StructuredLogger('discovery-service', event=event, context=context)
        
        # Context manager for scoped logging
        with logger.context(user_id='user123'):
            logger.info('Processing user request')
    """
    
    def __init__(
        self,
        service_name: str,
        correlation_id: Optional[str] = None,
        lambda_context: Optional[Any] = None,
        event: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize enhanced structured logger.
        
        Args:
            service_name: Name of the service/Lambda function
            correlation_id: Optional correlation ID for request tracing
            lambda_context: Optional Lambda context object
            event: Optional API Gateway event (for correlation ID extraction)
        """
        self.service_name = service_name
        self.context_stack = []
        
        # Extract correlation ID from multiple sources (priority order)
        self.correlation_id = self._extract_correlation_id(
            correlation_id, lambda_context, event
        )
        
        # Extract Lambda context info
        if lambda_context:
            self.function_name = getattr(lambda_context, 'function_name', None)
            self.function_version = getattr(lambda_context, 'function_version', None)
            self.request_id = getattr(lambda_context, 'aws_request_id', None)
        else:
            self.function_name = None
            self.function_version = None
            self.request_id = None
        
        # Configure logger
        self.logger = logging.getLogger(service_name)
        self.logger.setLevel(getattr(logging, LOG_LEVEL))
        
        # Remove default handlers
        self.logger.handlers = []
        
        # Add custom handler with JSON formatter
        handler = logging.StreamHandler()
        handler.setFormatter(JsonFormatter())
        self.logger.addHandler(handler)
    
    def _extract_correlation_id(
        self,
        correlation_id: Optional[str],
        lambda_context: Optional[Any],
        event: Optional[Dict[str, Any]]
    ) -> str:
        """
        Extract correlation ID from multiple sources.
        
        Priority:
        1. Explicitly provided correlation_id
        2. X-Correlation-ID header from API Gateway event
        3. X-Request-ID header from API Gateway event
        4. Lambda request ID from context
        5. Generate new UUID
        
        Args:
            correlation_id: Explicitly provided correlation ID
            lambda_context: Lambda context object
            event: API Gateway event
        
        Returns:
            str: Correlation ID
        """
        # 1. Explicit correlation ID
        if correlation_id:
            return correlation_id
        
        # 2. Extract from API Gateway event headers
        if event and isinstance(event, dict):
            headers = event.get('headers', {})
            if headers:
                # Try X-Correlation-ID
                for key in headers:
                    if key.lower() == 'x-correlation-id':
                        return headers[key]
                
                # Try X-Request-ID
                for key in headers:
                    if key.lower() == 'x-request-id':
                        return headers[key]
        
        # 3. Lambda request ID
        if lambda_context and hasattr(lambda_context, 'aws_request_id'):
            return lambda_context.aws_request_id
        
        # 4. Generate new UUID
        return str(uuid.uuid4())
    
    def _build_log_entry(self, level: str, message: str, **kwargs) -> Dict[str, Any]:
        """
        Build structured log entry.
        
        Args:
            level: Log level
            message: Log message
            **kwargs: Additional fields
        
        Returns:
            Dict: Structured log entry
        """
        log_entry = {
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'level': level,
            'service': self.service_name,
            'message': message,
            'correlation_id': self.correlation_id,
        }
        
        # Add Lambda context info
        if self.function_name:
            log_entry['function_name'] = self.function_name
        if self.function_version:
            log_entry['function_version'] = self.function_version
        if self.request_id:
            log_entry['request_id'] = self.request_id
        
        # Add context stack
        for context in self.context_stack:
            log_entry.update(context)
        
        # Add additional fields (sanitize sensitive data)
        sanitized_kwargs = sanitize_log_data(kwargs)
        log_entry.update(sanitized_kwargs)
        
        # Remove None values
        log_entry = {k: v for k, v in log_entry.items() if v is not None}
        
        return log_entry
    
    def _log(self, level: str, message: str, **kwargs):
        """
        Internal method to log structured messages.
        
        Args:
            level: Log level (INFO, WARN, ERROR, DEBUG)
            message: Log message
            **kwargs: Additional fields to include in log entry
        """
        log_entry = self._build_log_entry(level, message, **kwargs)
        
        # Log at appropriate level
        log_method = getattr(self.logger, level.lower())
        log_method(json.dumps(log_entry))
    
    def debug(self, message: str, **kwargs):
        """Log debug message."""
        self._log('DEBUG', message, **kwargs)
    
    def info(self, message: str, **kwargs):
        """Log info message."""
        self._log('INFO', message, **kwargs)
    
    def warn(self, message: str, **kwargs):
        """Log warning message."""
        self._log('WARN', message, **kwargs)
    
    def warning(self, message: str, **kwargs):
        """Alias for warn()."""
        self.warn(message, **kwargs)
    
    def error(self, message: str, **kwargs):
        """Log error message."""
        self._log('ERROR', message, **kwargs)
    
    def exception(self, message: str, exc_info=True, **kwargs):
        """Log exception with stack trace."""
        if exc_info:
            import traceback
            kwargs['exception'] = traceback.format_exc()
        self._log('ERROR', message, **kwargs)
    
    def set_correlation_id(self, correlation_id: str):
        """Update correlation ID for request tracing."""
        self.correlation_id = correlation_id
    
    def get_correlation_id(self) -> str:
        """Get current correlation ID."""
        return self.correlation_id
    
    @contextmanager
    def context(self, **kwargs):
        """
        Context manager for scoped logging with additional fields.
        
        Usage:
            with logger.context(user_id='user123', tenant='acme'):
                logger.info('Processing request')  # Includes user_id and tenant
        
        Args:
            **kwargs: Additional fields to include in all logs within context
        """
        self.context_stack.append(kwargs)
        try:
            yield self
        finally:
            self.context_stack.pop()
    
    def metric(self, metric_name: str, value: float, unit: str = 'Count', **dimensions):
        """
        Log a metric in CloudWatch Logs format.
        
        Args:
            metric_name: Name of the metric
            value: Metric value
            unit: Metric unit (Count, Milliseconds, Bytes, etc.)
            **dimensions: Additional dimensions for the metric
        """
        self.info(
            f'METRIC: {metric_name}',
            metric_name=metric_name,
            metric_value=value,
            metric_unit=unit,
            **dimensions
        )


class JsonFormatter(logging.Formatter):
    """
    Custom JSON formatter for CloudWatch Logs.
    """
    
    def format(self, record: logging.LogRecord) -> str:
        """
        Format log record as JSON string.
        
        Args:
            record: Log record
        
        Returns:
            str: JSON formatted log entry
        """
        # If message is already JSON, return as-is
        try:
            json.loads(record.getMessage())
            return record.getMessage()
        except (json.JSONDecodeError, ValueError):
            # Not JSON, wrap in structured format
            log_entry = {
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'level': record.levelname,
                'message': record.getMessage(),
            }
            
            # Add exception info if present
            if record.exc_info:
                log_entry['exception'] = self.formatException(record.exc_info)
            
            return json.dumps(log_entry)


def log_execution(logger: StructuredLogger):
    """
    Decorator to log function execution with timing.
    
    Usage:
        @log_execution(logger)
        def my_function(param1, param2):
            # function code
            return result
    
    Args:
        logger: StructuredLogger instance
    
    Returns:
        Decorated function
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = datetime.utcnow()
            function_name = func.__name__
            
            logger.debug(
                f'Function started: {function_name}',
                function=function_name,
                args_count=len(args),
                kwargs_count=len(kwargs)
            )
            
            try:
                result = func(*args, **kwargs)
                duration_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)
                
                logger.info(
                    f'Function completed: {function_name}',
                    function=function_name,
                    duration_ms=duration_ms,
                    status='success'
                )
                
                # Log performance metric
                logger.metric(
                    f'{function_name}_duration',
                    duration_ms,
                    'Milliseconds',
                    function=function_name
                )
                
                return result
                
            except Exception as e:
                duration_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)
                
                logger.error(
                    f'Function failed: {function_name}',
                    function=function_name,
                    duration_ms=duration_ms,
                    status='error',
                    error_type=type(e).__name__,
                    error_message=str(e)
                )
                
                raise
        
        return wrapper
    return decorator


def sanitize_log_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Remove sensitive data from log entries.
    
    Enhanced patterns:
    - Common secret keywords
    - AWS credentials
    - Database connection strings
    - Email addresses (partial redaction)
    - Credit card patterns
    
    Args:
        data: Dictionary containing log data
    
    Returns:
        Dict: Sanitized data with sensitive fields redacted
    
    Requirements: REQ-6.4 (data security)
    """
    sensitive_keys = [
        'password', 'secret', 'token', 'api_key', 'access_key',
        'secret_key', 'credential', 'authorization', 'session_token',
        'private_key', 'passphrase', 'auth', 'jwt', 'bearer',
        'aws_access_key_id', 'aws_secret_access_key', 'aws_session_token',
        'db_password', 'database_password', 'connection_string'
    ]
    
    sanitized = {}
    for key, value in data.items():
        # Check if key contains sensitive terms (case-insensitive)
        if any(sensitive in key.lower() for sensitive in sensitive_keys):
            sanitized[key] = '[REDACTED]'
        elif isinstance(value, dict):
            sanitized[key] = sanitize_log_data(value)
        elif isinstance(value, list):
            sanitized[key] = [
                sanitize_log_data(item) if isinstance(item, dict) else item
                for item in value
            ]
        elif isinstance(value, str):
            # Redact potential secrets in string values
            sanitized[key] = redact_patterns(value)
        else:
            sanitized[key] = value
    
    return sanitized


def redact_patterns(text: str) -> str:
    """
    Redact sensitive patterns in text.
    
    Args:
        text: Text to redact
    
    Returns:
        str: Text with sensitive patterns redacted
    """
    import re
    
    # AWS Access Key pattern
    text = re.sub(r'AKIA[0-9A-Z]{16}', '[REDACTED_AWS_KEY]', text)
    
    # AWS Secret Key pattern (40 characters)
    text = re.sub(r'[A-Za-z0-9/+=]{40}', '[REDACTED_SECRET]', text)
    
    # JWT token pattern
    text = re.sub(r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*', '[REDACTED_JWT]', text)
    
    # Email partial redaction (keep domain)
    text = re.sub(r'([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', r'[REDACTED]@\2', text)
    
    return text


def get_logger(
    service_name: str,
    correlation_id: Optional[str] = None,
    lambda_context: Optional[Any] = None,
    event: Optional[Dict[str, Any]] = None
) -> StructuredLogger:
    """
    Get an enhanced structured logger instance.
    
    Args:
        service_name: Name of the service/Lambda function
        correlation_id: Optional correlation ID for request tracing
        lambda_context: Optional Lambda context object
        event: Optional API Gateway event
    
    Returns:
        StructuredLogger: Configured logger instance
    
    Example:
        # In Lambda handler
        def lambda_handler(event, context):
            logger = get_logger('discovery-service', event=event, lambda_context=context)
            logger.info('Processing started')
            
            with logger.context(account_id='123456789012'):
                logger.info('Discovering resources')  # Includes account_id
    """
    return StructuredLogger(service_name, correlation_id, lambda_context, event)


# Example usage
if __name__ == '__main__':
    # Create logger
    logger = StructuredLogger('test-service', correlation_id='test-123')
    
    # Log messages
    logger.info('Test message', key1='value1', key2='value2')
    logger.warn('Warning message', warning_type='test')
    logger.error('Error message', error_code='ERR001')
    
    # Test context manager
    with logger.context(user_id='user123', tenant='acme'):
        logger.info('Processing user request')
        logger.info('Another log with context')
    
    # Test decorator
    @log_execution(logger)
    def test_function(x, y):
        return x + y
    
    result = test_function(1, 2)
    print(f"Result: {result}")
    
    # Test sanitization
    sensitive_data = {
        'username': 'john.doe@example.com',
        'password': 'secret123',
        'api_key': 'AKIAIOSFODNN7EXAMPLE',
        'instance_id': 'i-1234567890',
        'jwt_token': 'eyJTEST.eyJTEST.FAKE_JWT_TOKEN_FOR_TESTING'  # Fake JWT pattern for testing
    }
    sanitized = sanitize_log_data(sensitive_data)
    print(f"Sanitized: {json.dumps(sanitized, indent=2)}")
    
    # Test metric logging
    logger.metric('request_count', 1, 'Count', endpoint='/api/instances')
    logger.metric('response_time', 150, 'Milliseconds', endpoint='/api/instances')
