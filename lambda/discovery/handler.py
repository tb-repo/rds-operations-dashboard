"""
RDS Discovery Service Lambda Handler

Generated by: claude-3.5-sonnet
Timestamp: 2025-11-12T18:00:00Z
Version: 1.0.0
Policy Version: v1.0.0
Traceability: REQ-1.1, REQ-1.2, REQ-9.1 → DESIGN-001 → TASK-2
Review Status: Pending
Risk Level: Level 2

Purpose: Discover RDS instances across multiple AWS accounts and regions.
Assumes cross-account roles, queries RDS API, and extracts instance metadata.

Design Decisions:
- Parallel discovery across regions for performance
- Graceful failure handling (continue on per-account/region errors)
- Comprehensive metadata extraction for dashboard needs
- Tag-based environment classification
"""

import json
import os
from datetime import datetime
from typing import List, Dict, Any, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

# Import shared utilities
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from shared import AWSClients, StructuredLogger, Config, log_execution
from persistence import persist_instances
from monitoring import publish_discovery_metrics, send_discovery_notification

# Initialize logger
logger = StructuredLogger('discovery-service')


def lambda_handler(event, context):
    """
    Lambda handler for RDS instance discovery.
    
    Args:
        event: EventBridge scheduled event or manual invocation
        context: Lambda context
    
    Returns:
        dict: Discovery results summary
    
    Requirements: REQ-1.1 (multi-account discovery), REQ-1.2 (metadata extraction)
    """
    # Set correlation ID from request ID
    correlation_id = context.request_id if context else 'local-test'
    logger.set_correlation_id(correlation_id)
    
    logger.info('Discovery service started', 
                function_name=context.function_name if context else 'local',
                aws_request_id=correlation_id)
    
    try:
        # Load configuration
        config = Config.load()
        
        # Discover instances across all accounts and regions
        discovery_results = discover_all_instances(config)
        
        # Persist discovered instances to DynamoDB
        persistence_results = persist_instances(
            instances=discovery_results['instances'],
            config=config
        )
        
        # Publish metrics to CloudWatch
        publish_discovery_metrics(discovery_results, persistence_results, config)
        
        # Send SNS notification if needed
        send_discovery_notification(discovery_results, persistence_results, config)
        
        # Combine results
        final_results = {
            **discovery_results,
            'persistence': persistence_results
        }
        
        # Log summary
        logger.info('Discovery service completed',
                    total_instances=discovery_results['total_instances'],
                    accounts_scanned=discovery_results['accounts_scanned'],
                    regions_scanned=discovery_results['regions_scanned'],
                    new_instances=persistence_results['new_instances'],
                    updated_instances=persistence_results['updated_instances'],
                    deleted_instances=persistence_results['deleted_instances'],
                    errors=len(discovery_results['errors']) + persistence_results['errors'])
        
        return {
            'statusCode': 200,
            'body': json.dumps(final_results, default=str)
        }
        
    except Exception as e:
        logger.error('Discovery service failed',
                     error_type=type(e).__name__,
                     error_message=str(e))
        raise


@log_execution(logger)
def discover_all_instances(config: Any) -> Dict[str, Any]:
    """
    Discover RDS instances across all configured accounts and regions.
    
    Args:
        config: Application configuration
    
    Returns:
        dict: Discovery results with instances and errors
    
    Requirements: REQ-1.1 (multi-account, multi-region discovery)
    """
    all_instances = []
    errors = []
    accounts_scanned = 0
    regions_scanned = 0
    
    # Get target accounts and regions
    target_accounts = config.cross_account.target_accounts
    target_regions = config.cross_account.target_regions
    
    logger.info('Starting discovery',
                target_accounts=len(target_accounts),
                target_regions=len(target_regions))
    
    # Discover instances for each account
    for account_id in target_accounts:
        try:
            logger.info(f'Discovering instances in account: {account_id}',
                       account_id=account_id)
            
            # Discover across all regions for this account
            account_instances, account_errors = discover_account_instances(
                account_id=account_id,
                regions=target_regions,
                config=config
            )
            
            all_instances.extend(account_instances)
            errors.extend(account_errors)
            accounts_scanned += 1
            regions_scanned += len(target_regions)
            
            logger.info(f'Account discovery completed',
                       account_id=account_id,
                       instances_found=len(account_instances),
                       errors=len(account_errors))
            
        except Exception as e:
            error_msg = f'Failed to discover instances in account {account_id}: {str(e)}'
            logger.error(error_msg,
                        account_id=account_id,
                        error_type=type(e).__name__)
            errors.append({
                'account_id': account_id,
                'error': str(e),
                'timestamp': datetime.utcnow().isoformat() + 'Z'
            })
    
    return {
        'total_instances': len(all_instances),
        'instances': all_instances,
        'accounts_scanned': accounts_scanned,
        'regions_scanned': regions_scanned,
        'errors': errors,
        'discovery_timestamp': datetime.utcnow().isoformat() + 'Z'
    }


def discover_account_instances(
    account_id: str,
    regions: List[str],
    config: Any
) -> tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    """
    Discover RDS instances in a single account across multiple regions.
    Uses parallel execution for faster discovery.
    
    Args:
        account_id: AWS account ID
        regions: List of regions to scan
        config: Application configuration
    
    Returns:
        tuple: (instances, errors)
    
    Requirements: REQ-1.1 (multi-region discovery)
    """
    instances = []
    errors = []
    
    # Use ThreadPoolExecutor for parallel region scanning
    with ThreadPoolExecutor(max_workers=4) as executor:
        # Submit discovery tasks for each region
        future_to_region = {
            executor.submit(
                discover_region_instances,
                account_id,
                region,
                config
            ): region
            for region in regions
        }
        
        # Collect results as they complete
        for future in as_completed(future_to_region):
            region = future_to_region[future]
            try:
                region_instances = future.result()
                instances.extend(region_instances)
                
                logger.debug(f'Region discovery completed',
                            account_id=account_id,
                            region=region,
                            instances_found=len(region_instances))
                
            except Exception as e:
                error_msg = f'Failed to discover instances in {region}: {str(e)}'
                logger.error(error_msg,
                            account_id=account_id,
                            region=region,
                            error_type=type(e).__name__)
                errors.append({
                    'account_id': account_id,
                    'region': region,
                    'error': str(e),
                    'timestamp': datetime.utcnow().isoformat() + 'Z'
                })
    
    return instances, errors


def discover_region_instances(
    account_id: str,
    region: str,
    config: Any
) -> List[Dict[str, Any]]:
    """
    Discover RDS instances in a specific account and region.
    
    Args:
        account_id: AWS account ID
        region: AWS region
        config: Application configuration
    
    Returns:
        list: RDS instances with metadata
    
    Requirements: REQ-1.2 (metadata extraction), REQ-9.1 (cross-account access)
    """
    instances = []
    
    # Get RDS client (cross-account if needed)
    if account_id == os.environ.get('AWS_ACCOUNT_ID'):
        # Same account - no role assumption needed
        rds_client = AWSClients.get_rds_client(region=region)
    else:
        # Cross-account - assume role
        rds_client = AWSClients.get_rds_client(
            region=region,
            account_id=account_id,
            role_name=config.cross_account.role_name,
            external_id=config.cross_account.external_id
        )
    
    # Paginate through all DB instances
    paginator = rds_client.get_paginator('describe_db_instances')
    
    for page in paginator.paginate():
        for db_instance in page['DBInstances']:
            # Extract and normalize instance metadata
            instance_data = extract_instance_metadata(
                db_instance=db_instance,
                account_id=account_id,
                region=region
            )
            instances.append(instance_data)
    
    return instances


def extract_instance_metadata(
    db_instance: Dict[str, Any],
    account_id: str,
    region: str
) -> Dict[str, Any]:
    """
    Extract and normalize RDS instance metadata.
    
    Args:
        db_instance: RDS DBInstance object from API
        account_id: AWS account ID
        region: AWS region
    
    Returns:
        dict: Normalized instance metadata
    
    Requirements: REQ-1.2 (comprehensive metadata extraction)
    """
    # Extract tags
    tags = {}
    if 'TagList' in db_instance:
        tags = {tag['Key']: tag['Value'] for tag in db_instance['TagList']}
    
    # Determine environment from tags
    environment = tags.get('Environment', tags.get('environment', 'Unknown'))
    
    # Extract endpoint information
    endpoint = None
    port = None
    if 'Endpoint' in db_instance:
        endpoint = db_instance['Endpoint'].get('Address')
        port = db_instance['Endpoint'].get('Port')
    
    # Build normalized instance data
    instance_data = {
        # Identifiers
        'instance_id': db_instance['DBInstanceIdentifier'],
        'arn': db_instance['DBInstanceArn'],
        'account_id': account_id,
        'region': region,
        
        # Engine information
        'engine': db_instance['Engine'],
        'engine_version': db_instance['EngineVersion'],
        
        # Instance configuration
        'instance_class': db_instance['DBInstanceClass'],
        'storage_type': db_instance.get('StorageType', 'Unknown'),
        'allocated_storage': db_instance.get('AllocatedStorage', 0),
        'iops': db_instance.get('Iops'),
        'storage_encrypted': db_instance.get('StorageEncrypted', False),
        
        # Availability
        'multi_az': db_instance.get('MultiAZ', False),
        'availability_zone': db_instance.get('AvailabilityZone'),
        'status': db_instance['DBInstanceStatus'],
        
        # Network
        'endpoint': endpoint,
        'port': port,
        'publicly_accessible': db_instance.get('PubliclyAccessible', False),
        'vpc_id': db_instance.get('DBSubnetGroup', {}).get('VpcId'),
        
        # Backup configuration
        'backup_retention_period': db_instance.get('BackupRetentionPeriod', 0),
        'preferred_backup_window': db_instance.get('PreferredBackupWindow'),
        'latest_restorable_time': db_instance.get('LatestRestorableTime', '').isoformat() if db_instance.get('LatestRestorableTime') else None,
        
        # Maintenance
        'preferred_maintenance_window': db_instance.get('PreferredMaintenanceWindow'),
        'auto_minor_version_upgrade': db_instance.get('AutoMinorVersionUpgrade', False),
        'pending_modified_values': db_instance.get('PendingModifiedValues', {}),
        
        # Security
        'deletion_protection': db_instance.get('DeletionProtection', False),
        'iam_database_authentication_enabled': db_instance.get('IAMDatabaseAuthenticationEnabled', False),
        
        # Performance Insights
        'performance_insights_enabled': db_instance.get('PerformanceInsightsEnabled', False),
        
        # Tags and metadata
        'tags': tags,
        'environment': environment,
        
        # Discovery metadata
        'discovered_at': datetime.utcnow().isoformat() + 'Z',
        'last_updated': datetime.utcnow().isoformat() + 'Z'
    }
    
    return instance_data


# For local testing
if __name__ == '__main__':
    # Mock Lambda context
    class MockContext:
        request_id = 'test-request-123'
        function_name = 'rds-discovery-test'
    
    # Set environment variables for testing
    os.environ['INVENTORY_TABLE'] = 'rds-inventory-test'
    os.environ['METRICS_CACHE_TABLE'] = 'metrics-cache-test'
    os.environ['HEALTH_ALERTS_TABLE'] = 'health-alerts-test'
    os.environ['AUDIT_LOG_TABLE'] = 'audit-log-test'
    os.environ['DATA_BUCKET'] = 'rds-dashboard-data-test'
    os.environ['EXTERNAL_ID'] = 'test-external-id'
    os.environ['TARGET_ACCOUNTS'] = '["123456789012"]'
    os.environ['TARGET_REGIONS'] = '["ap-southeast-1"]'
    os.environ['SNS_TOPIC_ARN'] = 'arn:aws:sns:ap-southeast-1:123456789012:test'
    
    # Run handler
    result = lambda_handler({}, MockContext())
    print(json.dumps(result, indent=2))
