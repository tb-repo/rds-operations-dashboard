"""
RDS Discovery Data Persistence Module

Generated by: claude-3.5-sonnet
Timestamp: 2025-11-12T18:00:00Z
Version: 1.0.0
Policy Version: v1.0.0
Traceability: REQ-1.3, REQ-1.4 → DESIGN-001 → TASK-2.1
Review Status: Pending
Risk Level: Level 2

Purpose: Persist discovered RDS instances to DynamoDB with upsert logic.
Handles new, updated, and deleted instances with change tracking.

Design Decisions:
- Upsert pattern (PutItem with timestamps)
- Batch writes for performance (up to 25 items per batch)
- Soft delete tracking (mark as deleted rather than remove)
- Change detection for audit trail
"""

import os
from datetime import datetime
from typing import List, Dict, Any
from decimal import Decimal

import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from shared import AWSClients, StructuredLogger

logger = StructuredLogger('discovery-persistence')


def persist_instances(instances: List[Dict[str, Any]], config: Any) -> Dict[str, Any]:
    """
    Persist discovered instances to DynamoDB.
    
    Args:
        instances: List of discovered RDS instances
        config: Application configuration
    
    Returns:
        dict: Persistence results (new, updated, unchanged counts)
    
    Requirements: REQ-1.3 (data storage), REQ-1.4 (change tracking)
    """
    if not instances:
        logger.info('No instances to persist')
        return {
            'new_instances': 0,
            'updated_instances': 0,
            'unchanged_instances': 0,
            'errors': 0
        }
    
    logger.info(f'Persisting {len(instances)} instances to DynamoDB',
                instance_count=len(instances))
    
    # Get DynamoDB resource
    dynamodb = AWSClients.get_dynamodb_resource()
    table = dynamodb.Table(config.dynamodb.inventory_table)
    
    # Track results
    new_instances = 0
    updated_instances = 0
    unchanged_instances = 0
    errors = 0
    
    # Process instances in batches of 25 (DynamoDB batch write limit)
    batch_size = 25
    for i in range(0, len(instances), batch_size):
        batch = instances[i:i + batch_size]
        
        try:
            # Write batch to DynamoDB
            with table.batch_writer() as batch_writer:
                for instance in batch:
                    try:
                        # Check if instance exists
                        existing_item = get_existing_instance(
                            table=table,
                            instance_id=instance['instance_id']
                        )
                        
                        # Prepare item for DynamoDB
                        item = prepare_dynamodb_item(instance, existing_item)
                        
                        # Write to DynamoDB
                        batch_writer.put_item(Item=item)
                        
                        # Track change type
                        if existing_item is None:
                            new_instances += 1
                            logger.debug(f'New instance discovered',
                                        instance_id=instance['instance_id'])
                        elif has_changes(existing_item, item):
                            updated_instances += 1
                            logger.debug(f'Instance updated',
                                        instance_id=instance['instance_id'])
                        else:
                            unchanged_instances += 1
                        
                    except Exception as e:
                        logger.error(f'Failed to persist instance',
                                    instance_id=instance.get('instance_id'),
                                    error=str(e))
                        errors += 1
            
            logger.debug(f'Batch persisted',
                        batch_number=i // batch_size + 1,
                        batch_size=len(batch))
            
        except Exception as e:
            logger.error(f'Batch write failed',
                        batch_number=i // batch_size + 1,
                        error=str(e))
            errors += len(batch)
    
    # Mark deleted instances
    deleted_count = mark_deleted_instances(table, instances, config)
    
    results = {
        'new_instances': new_instances,
        'updated_instances': updated_instances,
        'unchanged_instances': unchanged_instances,
        'deleted_instances': deleted_count,
        'errors': errors,
        'total_processed': len(instances)
    }
    
    logger.info('Persistence completed',
                **results)
    
    return results


def get_existing_instance(table: Any, instance_id: str) -> Dict[str, Any]:
    """
    Get existing instance from DynamoDB.
    
    Args:
        table: DynamoDB table resource
        instance_id: RDS instance identifier
    
    Returns:
        dict: Existing instance data or None
    """
    try:
        response = table.get_item(Key={'instance_id': instance_id})
        return response.get('Item')
    except Exception as e:
        logger.debug(f'Instance not found in DynamoDB',
                    instance_id=instance_id)
        return None


def prepare_dynamodb_item(
    instance: Dict[str, Any],
    existing_item: Dict[str, Any] = None
) -> Dict[str, Any]:
    """
    Prepare instance data for DynamoDB storage.
    Converts floats to Decimal and handles timestamps.
    
    Args:
        instance: Instance data from discovery
        existing_item: Existing item from DynamoDB (if any)
    
    Returns:
        dict: Item ready for DynamoDB
    
    Requirements: REQ-1.4 (timestamp tracking)
    """
    # Convert floats to Decimal for DynamoDB
    item = convert_floats_to_decimal(instance)
    
    # Preserve created_at timestamp if exists
    if existing_item and 'created_at' in existing_item:
        item['created_at'] = existing_item['created_at']
    else:
        item['created_at'] = datetime.utcnow().isoformat() + 'Z'
    
    # Update last_updated timestamp
    item['last_updated'] = datetime.utcnow().isoformat() + 'Z'
    
    # Mark as active (not deleted)
    item['is_deleted'] = False
    
    return item


def convert_floats_to_decimal(obj: Any) -> Any:
    """
    Recursively convert float values to Decimal for DynamoDB compatibility.
    
    Args:
        obj: Object to convert
    
    Returns:
        Object with floats converted to Decimal
    """
    if isinstance(obj, float):
        return Decimal(str(obj))
    elif isinstance(obj, dict):
        return {k: convert_floats_to_decimal(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_floats_to_decimal(item) for item in obj]
    else:
        return obj


def has_changes(existing_item: Dict[str, Any], new_item: Dict[str, Any]) -> bool:
    """
    Check if instance has meaningful changes.
    Ignores timestamp fields for comparison.
    
    Args:
        existing_item: Existing item from DynamoDB
        new_item: New item to be written
    
    Returns:
        bool: True if there are changes
    """
    # Fields to ignore in comparison
    ignore_fields = {'last_updated', 'discovered_at', 'created_at'}
    
    # Compare all fields except ignored ones
    for key in new_item:
        if key in ignore_fields:
            continue
        
        if key not in existing_item:
            return True
        
        if existing_item[key] != new_item[key]:
            return True
    
    return False


def mark_deleted_instances(
    table: Any,
    discovered_instances: List[Dict[str, Any]],
    config: Any
) -> int:
    """
    Mark instances as deleted if they no longer exist in discovery.
    Uses soft delete (sets is_deleted flag) rather than removing items.
    
    Args:
        table: DynamoDB table resource
        discovered_instances: List of currently discovered instances
        config: Application configuration
    
    Returns:
        int: Number of instances marked as deleted
    
    Requirements: REQ-1.4 (change tracking)
    """
    # Get all instance IDs from discovery
    discovered_ids = {inst['instance_id'] for inst in discovered_instances}
    
    # Scan DynamoDB for active instances
    # Note: In production, consider using a GSI or maintaining a separate index
    try:
        response = table.scan(
            FilterExpression='attribute_not_exists(is_deleted) OR is_deleted = :false',
            ExpressionAttributeValues={':false': False}
        )
        
        existing_instances = response.get('Items', [])
        deleted_count = 0
        
        # Mark instances as deleted if not in discovery results
        for existing in existing_instances:
            if existing['instance_id'] not in discovered_ids:
                try:
                    table.update_item(
                        Key={'instance_id': existing['instance_id']},
                        UpdateExpression='SET is_deleted = :true, deleted_at = :timestamp',
                        ExpressionAttributeValues={
                            ':true': True,
                            ':timestamp': datetime.utcnow().isoformat() + 'Z'
                        }
                    )
                    deleted_count += 1
                    logger.info(f'Instance marked as deleted',
                               instance_id=existing['instance_id'])
                except Exception as e:
                    logger.error(f'Failed to mark instance as deleted',
                                instance_id=existing['instance_id'],
                                error=str(e))
        
        if deleted_count > 0:
            logger.info(f'Marked {deleted_count} instances as deleted')
        
        return deleted_count
        
    except Exception as e:
        logger.error(f'Failed to check for deleted instances',
                    error=str(e))
        return 0


def get_instance_count(config: Any) -> int:
    """
    Get total count of active instances in DynamoDB.
    
    Args:
        config: Application configuration
    
    Returns:
        int: Count of active instances
    """
    try:
        dynamodb = AWSClients.get_dynamodb_resource()
        table = dynamodb.Table(config.dynamodb.inventory_table)
        
        response = table.scan(
            Select='COUNT',
            FilterExpression='attribute_not_exists(is_deleted) OR is_deleted = :false',
            ExpressionAttributeValues={':false': False}
        )
        
        return response.get('Count', 0)
        
    except Exception as e:
        logger.error(f'Failed to get instance count', error=str(e))
        return 0
