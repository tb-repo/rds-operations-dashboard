"""
Configuration Management

Generated by: claude-3.5-sonnet
Timestamp: 2025-11-12T17:00:00Z
Version: 1.0.0
Policy Version: v1.0.0
Traceability: TASK-1 â†’ Infrastructure Setup
Review Status: Pending
Risk Level: Level 2

Purpose: Centralized configuration management for Lambda functions.
Loads configuration from environment variables with validation and defaults.

Design Decisions:
- Environment variables for configuration (12-factor app principle)
- Type validation and conversion
- Sensible defaults for optional settings
- Configuration caching to avoid repeated parsing
"""

import os
import json
from typing import List, Optional
from dataclasses import dataclass

# Import config file loader
try:
    from config_file_loader import ConfigFileLoader
except ImportError:
    ConfigFileLoader = None


@dataclass
class DynamoDBConfig:
    """DynamoDB table configuration."""
    inventory_table: str
    metrics_cache_table: str
    health_alerts_table: str
    audit_log_table: str


@dataclass
class S3Config:
    """S3 bucket configuration."""
    data_bucket: str


@dataclass
class CrossAccountConfig:
    """Cross-account access configuration."""
    role_name: str
    external_id: str
    target_accounts: List[str]
    target_regions: List[str]


@dataclass
class MonitoringConfig:
    """Monitoring and alerting configuration."""
    sns_topic_arn: str
    cloudwatch_namespace: str


@dataclass
class CacheConfig:
    """Cache configuration."""
    metrics_ttl_seconds: int
    cache_hit_threshold: float


@dataclass
class AppConfig:
    """Application configuration."""
    environment: str
    region: str
    log_level: str
    dynamodb: DynamoDBConfig
    s3: S3Config
    cross_account: CrossAccountConfig
    monitoring: MonitoringConfig
    cache: CacheConfig
    
    def get(self, key: str, default=None):
        """
        Dict-like get method for backward compatibility.
        
        Args:
            key: Configuration key
            default: Default value if key not found
            
        Returns:
            Configuration value or default
        """
        # Map old dict-style keys to new dataclass attributes
        key_mapping = {
            'environment': self.environment,
            'region': self.region,
            'log_level': self.log_level,
            'dynamodb_tables': {
                'rds_inventory': self.dynamodb.inventory_table,
                'metrics_cache': self.dynamodb.metrics_cache_table,
                'health_alerts': self.dynamodb.health_alerts_table,
                'audit_log': self.dynamodb.audit_log_table
            },
            'data_bucket': self.s3.data_bucket,
            'sns_topic_arn': self.monitoring.sns_topic_arn,
            'cloudwatch_namespace': self.monitoring.cloudwatch_namespace,
            'external_id': self.cross_account.external_id,
            'cross_account_role_name': self.cross_account.role_name,
            'target_accounts': self.cross_account.target_accounts,
            'target_regions': self.cross_account.target_regions,
            'metrics_ttl_seconds': self.cache.metrics_ttl_seconds,
            'cache_hit_threshold': self.cache.cache_hit_threshold
        }
        
        return key_mapping.get(key, default)


class ConfigurationError(Exception):
    """Raised when configuration is invalid or missing."""
    pass


class Config:
    """
    Configuration manager for Lambda functions.
    
    Usage:
        config = Config.load()
        print(config.dynamodb.inventory_table)
        print(config.cross_account.target_accounts)
    """
    
    _instance: Optional[AppConfig] = None
    
    @classmethod
    def load(cls) -> AppConfig:
        """
        Load configuration from file (preferred) or environment variables (fallback).
        Configuration is cached after first load.
        
        Returns:
            AppConfig: Application configuration
        
        Raises:
            ConfigurationError: If required configuration is missing
        """
        if cls._instance is not None:
            return cls._instance
        
        try:
            # Try loading from config file first
            config_file = None
            if ConfigFileLoader:
                data_bucket = os.environ.get('DATA_BUCKET')
                if data_bucket:
                    # Try loading from S3
                    try:
                        config_file = ConfigFileLoader.load(
                            s3_bucket=data_bucket,
                            s3_key='config/dashboard-config.json'
                        )
                    except:
                        # Fall back to local file
                        config_file = ConfigFileLoader.load()
                else:
                    config_file = ConfigFileLoader.load()
            # Environment
            environment = os.environ.get('ENVIRONMENT', 'prod')
            region = os.environ.get('AWS_REGION', 'ap-southeast-1')
            log_level = os.environ.get('LOG_LEVEL', 'INFO')
            
            # DynamoDB tables
            dynamodb = DynamoDBConfig(
                inventory_table=cls._get_required('INVENTORY_TABLE'),
                metrics_cache_table=cls._get_required('METRICS_CACHE_TABLE'),
                health_alerts_table=cls._get_required('HEALTH_ALERTS_TABLE'),
                audit_log_table=cls._get_required('AUDIT_LOG_TABLE'),
            )
            
            # S3 bucket
            s3 = S3Config(
                data_bucket=cls._get_required('DATA_BUCKET'),
            )
            
            # Cross-account configuration (from file or env vars)
            if config_file and ConfigFileLoader:
                cross_account = CrossAccountConfig(
                    role_name=ConfigFileLoader.get_role_name(config_file),
                    external_id=ConfigFileLoader.get_external_id(config_file),
                    target_accounts=ConfigFileLoader.get_enabled_accounts(config_file),
                    target_regions=ConfigFileLoader.get_enabled_regions(config_file),
                )
            else:
                # Fallback to environment variables
                cross_account = CrossAccountConfig(
                    role_name=os.environ.get('CROSS_ACCOUNT_ROLE_NAME', 'RDSDashboardCrossAccountRole'),
                    external_id=cls._get_required('EXTERNAL_ID'),
                    target_accounts=cls._parse_json_list('TARGET_ACCOUNTS', []),
                    target_regions=cls._parse_json_list(
                        'TARGET_REGIONS',
                        ['ap-southeast-1', 'eu-west-2', 'ap-south-1', 'us-east-1']
                    ),
                )
            
            # Monitoring
            monitoring = MonitoringConfig(
                sns_topic_arn=cls._get_required('SNS_TOPIC_ARN'),
                cloudwatch_namespace=os.environ.get('CLOUDWATCH_NAMESPACE', 'RDSDashboard'),
            )
            
            # Cache configuration
            cache = CacheConfig(
                metrics_ttl_seconds=int(os.environ.get('METRICS_TTL_SECONDS', '300')),  # 5 minutes
                cache_hit_threshold=float(os.environ.get('CACHE_HIT_THRESHOLD', '0.7')),  # 70%
            )
            
            cls._instance = AppConfig(
                environment=environment,
                region=region,
                log_level=log_level,
                dynamodb=dynamodb,
                s3=s3,
                cross_account=cross_account,
                monitoring=monitoring,
                cache=cache,
            )
            
            return cls._instance
            
        except Exception as e:
            raise ConfigurationError(f"Failed to load configuration: {str(e)}")
    
    @staticmethod
    def _get_required(key: str) -> str:
        """
        Get required environment variable.
        
        Args:
            key: Environment variable name
        
        Returns:
            str: Environment variable value
        
        Raises:
            ConfigurationError: If variable is not set
        """
        value = os.environ.get(key)
        if not value:
            raise ConfigurationError(f"Required environment variable not set: {key}")
        return value
    
    @staticmethod
    def _parse_json_list(key: str, default: List[str]) -> List[str]:
        """
        Parse JSON list from environment variable.
        
        Args:
            key: Environment variable name
            default: Default value if not set
        
        Returns:
            List[str]: Parsed list
        """
        value = os.environ.get(key)
        if not value:
            return default
        
        try:
            parsed = json.loads(value)
            if not isinstance(parsed, list):
                raise ValueError(f"{key} must be a JSON array")
            return parsed
        except json.JSONDecodeError as e:
            raise ConfigurationError(f"Invalid JSON in {key}: {str(e)}")
    
    @classmethod
    def reload(cls):
        """
        Force reload configuration from environment variables.
        Useful for testing.
        """
        cls._instance = None
        return cls.load()


# Example usage
if __name__ == '__main__':
    # Set example environment variables
    os.environ['INVENTORY_TABLE'] = 'rds-inventory-prod'
    os.environ['METRICS_CACHE_TABLE'] = 'metrics-cache-prod'
    os.environ['HEALTH_ALERTS_TABLE'] = 'health-alerts-prod'
    os.environ['AUDIT_LOG_TABLE'] = 'audit-log-prod'
    os.environ['DATA_BUCKET'] = 'rds-dashboard-data-123456789012-prod'
    os.environ['EXTERNAL_ID'] = 'rds-dashboard-unique-id-12345'
    os.environ['TARGET_ACCOUNTS'] = '["123456789012", "234567890123"]'
    os.environ['SNS_TOPIC_ARN'] = 'arn:aws:sns:ap-southeast-1:123456789012:rds-dashboard-alerts-prod'
    
    # Load configuration
    config = Config.load()
    
    # Print configuration
    print(f"Environment: {config.environment}")
    print(f"Region: {config.region}")
    print(f"Inventory Table: {config.dynamodb.inventory_table}")
    print(f"Target Accounts: {config.cross_account.target_accounts}")
    print(f"Target Regions: {config.cross_account.target_regions}")
    print(f"Cache TTL: {config.cache.metrics_ttl_seconds}s")
