"""
Structured Logging Utility

Generated by: claude-3.5-sonnet
Timestamp: 2025-11-12T17:00:00Z
Version: 1.0.0
Policy Version: v1.0.0
Traceability: REQ-10.2, REQ-10.3 → DESIGN-001 → TASK-1
Review Status: Pending
Risk Level: Level 2

Purpose: Provide structured JSON logging for all Lambda functions with
correlation IDs, metrics, and consistent formatting for CloudWatch Logs.

Design Decisions:
- JSON format for programmatic parsing and analysis
- Correlation IDs for request tracing across services
- Automatic inclusion of Lambda context (request ID, function name)
- Configurable log levels via environment variables
- No sensitive data logging (PII, credentials)
"""

import json
import logging
import os
from datetime import datetime
from typing import Any, Dict, Optional
from functools import wraps

# Log level from environment variable
LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO').upper()


class StructuredLogger:
    """
    Structured JSON logger for Lambda functions.
    
    Usage:
        logger = StructuredLogger('discovery-service')
        logger.info('Discovery started', account_id='123456789012', region='ap-southeast-1')
        logger.error('Discovery failed', error='Connection timeout', account_id='123456789012')
    
    With Lambda context:
        logger = StructuredLogger('discovery-service', lambda_context=context)
        # Automatically extracts request_id as correlation_id
    """
    
    def __init__(
        self,
        service_name: str,
        correlation_id: Optional[str] = None,
        lambda_context: Optional[Any] = None
    ):
        """
        Initialize structured logger.
        
        Args:
            service_name: Name of the service/Lambda function
            correlation_id: Optional correlation ID for request tracing
            lambda_context: Optional Lambda context object (auto-extracts request_id)
        """
        self.service_name = service_name
        
        # Extract correlation ID from Lambda context if available
        if lambda_context and hasattr(lambda_context, 'aws_request_id'):
            self.correlation_id = lambda_context.aws_request_id
            self.function_name = lambda_context.function_name if hasattr(lambda_context, 'function_name') else None
            self.function_version = lambda_context.function_version if hasattr(lambda_context, 'function_version') else None
        else:
            self.correlation_id = correlation_id
            self.function_name = None
            self.function_version = None
        
        self.logger = logging.getLogger(service_name)
        self.logger.setLevel(getattr(logging, LOG_LEVEL))
        
        # Remove default handlers
        self.logger.handlers = []
        
        # Add custom handler with JSON formatter
        handler = logging.StreamHandler()
        handler.setFormatter(JsonFormatter())
        self.logger.addHandler(handler)
    
    def _log(self, level: str, message: str, **kwargs):
        """
        Internal method to log structured messages.
        
        Args:
            level: Log level (INFO, WARN, ERROR, DEBUG)
            message: Log message
            **kwargs: Additional fields to include in log entry
        """
        log_entry = {
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'level': level,
            'service': self.service_name,
            'message': message,
        }
        
        # Add correlation ID if available
        if self.correlation_id:
            log_entry['correlation_id'] = self.correlation_id
        
        # Add Lambda context info if available
        if self.function_name:
            log_entry['function_name'] = self.function_name
        if self.function_version:
            log_entry['function_version'] = self.function_version
        
        # Add additional fields (sanitize sensitive data)
        sanitized_kwargs = sanitize_log_data(kwargs)
        log_entry.update(sanitized_kwargs)
        
        # Remove None values
        log_entry = {k: v for k, v in log_entry.items() if v is not None}
        
        # Log at appropriate level
        if level == 'DEBUG':
            self.logger.debug(json.dumps(log_entry))
        elif level == 'INFO':
            self.logger.info(json.dumps(log_entry))
        elif level == 'WARN':
            self.logger.warning(json.dumps(log_entry))
        elif level == 'ERROR':
            self.logger.error(json.dumps(log_entry))
    
    def debug(self, message: str, **kwargs):
        """Log debug message."""
        self._log('DEBUG', message, **kwargs)
    
    def info(self, message: str, **kwargs):
        """Log info message."""
        self._log('INFO', message, **kwargs)
    
    def warn(self, message: str, **kwargs):
        """Log warning message."""
        self._log('WARN', message, **kwargs)
    
    def error(self, message: str, **kwargs):
        """Log error message."""
        self._log('ERROR', message, **kwargs)
    
    def set_correlation_id(self, correlation_id: str):
        """Update correlation ID for request tracing."""
        self.correlation_id = correlation_id


class JsonFormatter(logging.Formatter):
    """
    Custom JSON formatter for CloudWatch Logs.
    """
    
    def format(self, record: logging.LogRecord) -> str:
        """
        Format log record as JSON string.
        
        Args:
            record: Log record
        
        Returns:
            str: JSON formatted log entry
        """
        # If message is already JSON, return as-is
        try:
            json.loads(record.getMessage())
            return record.getMessage()
        except (json.JSONDecodeError, ValueError):
            # Not JSON, wrap in structured format
            log_entry = {
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'level': record.levelname,
                'message': record.getMessage(),
            }
            
            # Add exception info if present
            if record.exc_info:
                log_entry['exception'] = self.formatException(record.exc_info)
            
            return json.dumps(log_entry)


def log_execution(logger: StructuredLogger):
    """
    Decorator to log function execution with timing.
    
    Usage:
        @log_execution(logger)
        def my_function(param1, param2):
            # function code
            return result
    
    Args:
        logger: StructuredLogger instance
    
    Returns:
        Decorated function
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = datetime.utcnow()
            function_name = func.__name__
            
            logger.info(
                f'Function started: {function_name}',
                function=function_name,
                args_count=len(args),
                kwargs_count=len(kwargs)
            )
            
            try:
                result = func(*args, **kwargs)
                duration_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)
                
                logger.info(
                    f'Function completed: {function_name}',
                    function=function_name,
                    duration_ms=duration_ms,
                    status='success'
                )
                
                return result
                
            except Exception as e:
                duration_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)
                
                logger.error(
                    f'Function failed: {function_name}',
                    function=function_name,
                    duration_ms=duration_ms,
                    status='error',
                    error_type=type(e).__name__,
                    error_message=str(e)
                )
                
                raise
        
        return wrapper
    return decorator


def sanitize_log_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Remove sensitive data from log entries.
    
    Args:
        data: Dictionary containing log data
    
    Returns:
        Dict: Sanitized data with sensitive fields redacted
    
    Requirements: REQ-9.3 (data security)
    """
    sensitive_keys = [
        'password', 'secret', 'token', 'api_key', 'access_key',
        'secret_key', 'credential', 'authorization', 'session_token'
    ]
    
    sanitized = {}
    for key, value in data.items():
        # Check if key contains sensitive terms (case-insensitive)
        if any(sensitive in key.lower() for sensitive in sensitive_keys):
            sanitized[key] = '[REDACTED]'
        elif isinstance(value, dict):
            sanitized[key] = sanitize_log_data(value)
        elif isinstance(value, list):
            sanitized[key] = [
                sanitize_log_data(item) if isinstance(item, dict) else item
                for item in value
            ]
        else:
            sanitized[key] = value
    
    return sanitized


def get_logger(
    service_name: str,
    correlation_id: Optional[str] = None,
    lambda_context: Optional[Any] = None
) -> StructuredLogger:
    """
    Get a structured logger instance.
    
    Args:
        service_name: Name of the service/Lambda function
        correlation_id: Optional correlation ID for request tracing
        lambda_context: Optional Lambda context object (auto-extracts request_id)
    
    Returns:
        StructuredLogger: Configured logger instance
    
    Example:
        # In Lambda handler
        def lambda_handler(event, context):
            logger = get_logger('discovery-service', lambda_context=context)
            logger.info('Processing started')
    """
    return StructuredLogger(service_name, correlation_id, lambda_context)


# Example usage
if __name__ == '__main__':
    # Create logger
    logger = StructuredLogger('test-service', correlation_id='test-123')
    
    # Log messages
    logger.info('Test message', key1='value1', key2='value2')
    logger.warn('Warning message', warning_type='test')
    logger.error('Error message', error_code='ERR001')
    
    # Test decorator
    @log_execution(logger)
    def test_function(x, y):
        return x + y
    
    result = test_function(1, 2)
    print(f"Result: {result}")
    
    # Test sanitization
    sensitive_data = {
        'username': 'john.doe',
        'password': 'secret123',
        'api_key': 'abc123',
        'instance_id': 'i-1234567890'
    }
    sanitized = sanitize_log_data(sensitive_data)
    print(f"Sanitized: {json.dumps(sanitized, indent=2)}")
