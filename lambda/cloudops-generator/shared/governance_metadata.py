"""
Governance Metadata Utility Module

Provides utilities for adding and extracting governance metadata from code artifacts
according to AI SDLC Governance Framework requirements.

Generated by: claude-3.5-sonnet
Timestamp: 2025-12-02T00:00:00Z
Version: 1.0.0
Policy Version: v1.0.0
Traceability: REQ-3.1 → DESIGN-3.1 → TASK-3.2
Review Status: Pending
Risk Level: Level 2
"""

import json
import re
from datetime import datetime, timezone
from typing import Dict, Any, Optional


class ValidationError(Exception):
    """Custom validation error for metadata validation."""
    pass


# Required fields for governance metadata
REQUIRED_FIELDS = [
    "generated_by",
    "timestamp",
    "version",
    "policy_version",
    "traceability",
    "review_status",
    "risk_level"
]

VALID_REVIEW_STATUSES = ["Pending", "Approved", "Rejected"]
VALID_RISK_LEVELS = ["Level 1", "Level 2", "Level 3"]


def add_metadata(
    generated_by: str = "claude-3.5-sonnet",
    version: str = "1.0.0",
    policy_version: str = "v1.0.0",
    traceability: str = "",
    review_status: str = "Pending",
    risk_level: str = "Level 2",
    reviewed_by: Optional[str] = None,
    approved_by: Optional[str] = None
) -> Dict[str, Any]:
    """
    Generate governance metadata dictionary for code artifacts.
    
    Args:
        generated_by: AI model identifier
        version: Artifact version
        policy_version: Governance policy version
        traceability: Requirement → Design → Task chain
        review_status: Current review status
        risk_level: Risk classification (Level 1/2/3)
        reviewed_by: Reviewer identifier (optional)
        approved_by: Approver identifier (optional)
    
    Returns:
        Dictionary containing governance metadata
    
    Raises:
        ValidationError: If metadata doesn't match schema
    """
    metadata = {
        "generated_by": generated_by,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "version": version,
        "policy_version": policy_version,
        "traceability": traceability,
        "review_status": review_status,
        "risk_level": risk_level,
        "reviewed_by": reviewed_by,
        "approved_by": approved_by
    }
    
    # Validate metadata
    _validate_metadata(metadata)
    
    return metadata


def _validate_metadata(metadata: Dict[str, Any]) -> None:
    """
    Validate metadata dictionary.
    
    Args:
        metadata: Metadata dictionary to validate
    
    Raises:
        ValidationError: If metadata is invalid
    """
    # Check required fields
    for field in REQUIRED_FIELDS:
        if field not in metadata:
            raise ValidationError(f"Missing required field: {field}")
    
    # Validate review_status
    if metadata["review_status"] not in VALID_REVIEW_STATUSES:
        raise ValidationError(f"Invalid review_status: {metadata['review_status']}")
    
    # Validate risk_level
    if metadata["risk_level"] not in VALID_RISK_LEVELS:
        raise ValidationError(f"Invalid risk_level: {metadata['risk_level']}")


def format_metadata_block(metadata: Dict[str, Any], comment_style: str = "python") -> str:
    """
    Format metadata as a comment block for insertion into code.
    
    Args:
        metadata: Metadata dictionary
        comment_style: Comment style ('python', 'javascript', 'typescript')
    
    Returns:
        Formatted metadata block as string
    """
    json_str = json.dumps(metadata, indent=2)
    
    if comment_style == "python":
        lines = ['"""', 'Governance Metadata:']
        lines.extend(json_str.split('\n'))
        lines.append('"""')
        return '\n'.join(lines)
    
    elif comment_style in ["javascript", "typescript"]:
        lines = ['/**', ' * Governance Metadata:']
        for line in json_str.split('\n'):
            lines.append(f' * {line}')
        lines.append(' */')
        return '\n'.join(lines)
    
    else:
        raise ValueError(f"Unsupported comment style: {comment_style}")


def extract_metadata(content: str) -> Optional[Dict[str, Any]]:
    """
    Extract governance metadata from code content.
    
    Args:
        content: Source code content as string
    
    Returns:
        Metadata dictionary if found, None otherwise
    
    Raises:
        ValidationError: If extracted metadata doesn't match schema
    """
    # Try Python-style docstring
    python_pattern = r'"""[\s\S]*?Governance Metadata:\s*(\{[\s\S]*?\})\s*"""'
    match = re.search(python_pattern, content)
    
    if not match:
        # Try JavaScript/TypeScript-style comment
        js_pattern = r'/\*\*[\s\S]*?Governance Metadata:\s*\n([\s\S]*?)\*/'
        match = re.search(js_pattern, content)
        
        if match:
            # Clean up comment markers
            json_str = match.group(1)
            json_str = re.sub(r'^\s*\*\s*', '', json_str, flags=re.MULTILINE)
        else:
            return None
    else:
        json_str = match.group(1)
    
    try:
        metadata = json.loads(json_str)
        _validate_metadata(metadata)
        return metadata
    except (json.JSONDecodeError, ValidationError):
        return None


def update_metadata_status(
    content: str,
    review_status: Optional[str] = None,
    reviewed_by: Optional[str] = None,
    approved_by: Optional[str] = None
) -> str:
    """
    Update metadata status fields in existing code content.
    
    Args:
        content: Source code content
        review_status: New review status (optional)
        reviewed_by: Reviewer identifier (optional)
        approved_by: Approver identifier (optional)
    
    Returns:
        Updated content with modified metadata
    
    Raises:
        ValueError: If no metadata found in content
    """
    metadata = extract_metadata(content)
    
    if metadata is None:
        raise ValueError("No governance metadata found in content")
    
    # Update fields
    if review_status:
        metadata["review_status"] = review_status
    if reviewed_by:
        metadata["reviewed_by"] = reviewed_by
    if approved_by:
        metadata["approved_by"] = approved_by
    
    # Validate updated metadata
    _validate_metadata(metadata)
    
    # Determine comment style from content
    if '"""' in content:
        comment_style = "python"
    else:
        comment_style = "javascript"
    
    # Replace old metadata block with new one
    new_block = format_metadata_block(metadata, comment_style)
    
    if comment_style == "python":
        pattern = r'"""[\s\S]*?Governance Metadata:[\s\S]*?"""'
    else:
        pattern = r'/\*\*[\s\S]*?Governance Metadata:[\s\S]*?\*/'
    
    updated_content = re.sub(pattern, new_block, content, count=1)
    
    return updated_content


def validate_metadata_dict(metadata: Dict[str, Any]) -> bool:
    """
    Validate metadata dictionary.
    
    Args:
        metadata: Metadata dictionary to validate
    
    Returns:
        True if valid, False otherwise
    """
    try:
        _validate_metadata(metadata)
        return True
    except ValidationError:
        return False
