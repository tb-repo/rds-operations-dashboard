"""
Account Discovery Service for Automated Onboarding

Generated by: claude-3.5-sonnet
Timestamp: 2025-12-08T00:00:00Z
Version: 1.0.0
Policy Version: v1.0.0
Traceability: REQ-1.1, REQ-1.2, REQ-1.3, REQ-1.4 → DESIGN-001 → TASK-2.1
Review Status: Pending
Risk Level: Level 2

Purpose: Automatically discover new AWS accounts from AWS Organizations and
initialize onboarding requests in DynamoDB.

Design Decisions:
- Uses AWS Organizations API to list accounts
- Implements pagination for large account lists
- Checks for duplicate onboarding requests before creating
- Uses circuit breaker pattern for Organizations API calls
- Structured logging with correlation IDs for traceability

Requirements:
- REQ-1.1: Detect new accounts within 15 minutes
- REQ-1.2: Retrieve account ID and name from Organizations
- REQ-1.3: Store account metadata in configuration database
- REQ-1.4: Process multiple accounts independently
"""

import os
import sys
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional, Dict, Any

import boto3
from botocore.exceptions import ClientError

# Add shared module to path
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from shared.structured_logger import get_logger
from shared.aws_clients import AWSClients
from shared.circuit_breaker import circuit_breaker, CircuitBreakerError


@dataclass
class AccountInfo:
    """
    Account information from AWS Organizations.
    
    Attributes:
        account_id: 12-digit AWS account ID
        account_name: Friendly name from Organizations
        email: Root account email
        organizational_unit: OU path (if available)
        status: Account status (ACTIVE, SUSPENDED, etc.)
        joined_timestamp: When account joined organization
        tags: Account tags
    """
    account_id: str
    account_name: str
    email: str
    organizational_unit: Optional[str] = None
    status: str = "ACTIVE"
    joined_timestamp: Optional[datetime] = None
    tags: Optional[Dict[str, str]] = None


class AccountDiscoveryService:
    """
    Service for discovering new AWS accounts from Organizations.
    
    Features:
    - Automatic account discovery from AWS Organizations
    - Pagination support for large account lists
    - Duplicate detection before creating onboarding requests
    - Circuit breaker protection for Organizations API
    - Structured logging with correlation IDs
    """
    
    def __init__(
        self,
        dynamodb_table_name: str,
        correlation_id: Optional[str] = None,
        logger=None
    ):
        """
        Initialize Account Discovery Service.
        
        Args:
            dynamodb_table_name: Name of onboarding state DynamoDB table
            correlation_id: Optional correlation ID for request tracing
            logger: Optional logger instance
        """
        self.dynamodb_table_name = dynamodb_table_name
        self.logger = logger or get_logger('account-discovery', correlation_id=correlation_id)
        
        # Initialize AWS clients
        # Use us-east-1 for Organizations (global service, ap-southeast-1 endpoint has issues)
        import botocore.config
        config = botocore.config.Config(
            connect_timeout=10,
            read_timeout=30,
            retries={'max_attempts': 2}
        )
        self.organizations_client = boto3.client(
            'organizations',
            region_name='us-east-1',  # Organizations is global, use working endpoint
            config=config
        )
        self.dynamodb = AWSClients.get_dynamodb_resource()
        self.table = self.dynamodb.Table(dynamodb_table_name)
        
        self.logger.info(
            'Account Discovery Service initialized',
            dynamodb_table=dynamodb_table_name,
            organizations_region='us-east-1'
        )
    
    @circuit_breaker(
        name='organizations_api',
        failure_threshold=5,
        timeout=300.0,  # 5 minutes cooldown
        expected_exception=ClientError
    )
    def discover_new_accounts(self) -> List[AccountInfo]:
        """
        Query AWS Organizations and return list of all accounts.
        
        Implements pagination to handle large numbers of accounts.
        Uses circuit breaker to prevent cascading failures.
        
        Returns:
            List of AccountInfo objects for all accounts in organization
            
        Raises:
            ClientError: If Organizations API call fails
            CircuitBreakerError: If circuit breaker is open
            
        Requirements: REQ-1.1, REQ-1.2
        Validates: Property 1 (Account Detection Timeliness)
        Validates: Property 2 (Account Data Retrieval Completeness)
        """
        self.logger.info('Starting account discovery from AWS Organizations')
        
        accounts = []
        next_token = None
        page_count = 0
        
        try:
            while True:
                page_count += 1
                self.logger.info(f'Fetching accounts page {page_count}', page=page_count)
                
                # List accounts with pagination
                if next_token:
                    response = self.organizations_client.list_accounts(NextToken=next_token)
                else:
                    response = self.organizations_client.list_accounts()
                
                self.logger.info(f'Received response for page {page_count}', 
                               accounts_in_page=len(response.get('Accounts', [])))
                
                # Process accounts from this page
                for account in response.get('Accounts', []):
                    account_info = self._parse_account(account)
                    if account_info:
                        accounts.append(account_info)
                
                # Check for more pages
                next_token = response.get('NextToken')
                if not next_token:
                    break
            
            self.logger.info(
                'Account discovery completed',
                total_accounts=len(accounts),
                pages_fetched=page_count
            )
            
            return accounts
            
        except ClientError as e:
            error_code = e.response['Error']['Code']
            error_message = e.response['Error']['Message']
            
            self.logger.error(
                'Failed to discover accounts from Organizations',
                error_code=error_code,
                error_message=error_message
            )
            raise
        except CircuitBreakerError as e:
            self.logger.error(
                'Circuit breaker is open for Organizations API',
                error_message=str(e)
            )
            raise
        except Exception as e:
            self.logger.error(
                'Unexpected error during account discovery',
                error_type=type(e).__name__,
                error_message=str(e)
            )
            raise
    
    def _parse_account(self, account_data: Dict[str, Any]) -> Optional[AccountInfo]:
        """
        Parse account data from Organizations API response.
        
        Args:
            account_data: Account dictionary from Organizations API
            
        Returns:
            AccountInfo object or None if parsing fails
        """
        try:
            # Parse joined timestamp
            joined_timestamp = None
            if 'JoinedTimestamp' in account_data:
                joined_timestamp = account_data['JoinedTimestamp']
                if not isinstance(joined_timestamp, datetime):
                    # Convert if it's a string
                    from dateutil import parser
                    joined_timestamp = parser.parse(str(joined_timestamp))
            
            account_info = AccountInfo(
                account_id=account_data['Id'],
                account_name=account_data.get('Name', 'Unknown'),
                email=account_data.get('Email', ''),
                status=account_data.get('Status', 'ACTIVE'),
                joined_timestamp=joined_timestamp
            )
            
            return account_info
            
        except (KeyError, ValueError) as e:
            self.logger.warning(
                'Failed to parse account data',
                error=str(e),
                account_data=account_data
            )
            return None
    
    def is_account_onboarded(self, account_id: str) -> bool:
        """
        Check if account already exists in onboarding system.
        
        Args:
            account_id: AWS account ID (12 digits)
            
        Returns:
            True if account is already onboarded or in progress
            
        Requirements: REQ-1.4 (prevent duplicate processing)
        """
        try:
            response = self.table.get_item(Key={'account_id': account_id})
            
            if 'Item' in response:
                status = response['Item'].get('status', 'unknown')
                self.logger.debug(
                    'Account already exists in onboarding system',
                    account_id=account_id,
                    status=status
                )
                return True
            
            return False
            
        except ClientError as e:
            self.logger.error(
                'Failed to check if account is onboarded',
                account_id=account_id,
                error=str(e)
            )
            # On error, assume account exists to prevent duplicates
            return True
    
    def create_onboarding_request(self, account: AccountInfo) -> Dict[str, Any]:
        """
        Create new onboarding request in DynamoDB.
        
        Args:
            account: AccountInfo object with account details
            
        Returns:
            Dictionary with onboarding request details
            
        Raises:
            ClientError: If DynamoDB operation fails
            
        Requirements: REQ-1.3 (store account metadata)
        Validates: Property 3 (Account Metadata Round-Trip Consistency)
        """
        self.logger.info(
            'Creating onboarding request',
            account_id=account.account_id,
            account_name=account.account_name
        )
        
        # Prepare onboarding request item
        now = datetime.utcnow().isoformat() + 'Z'
        
        item = {
            'account_id': account.account_id,
            'account_name': account.account_name,
            'email': account.email,
            'organizational_unit': account.organizational_unit or 'Unknown',
            'status': 'pending',  # Initial status
            'created_at': now,
            'last_updated_at': now,
            'retry_count': 0,
        }
        
        # Add optional fields
        if account.joined_timestamp:
            item['joined_timestamp'] = account.joined_timestamp.isoformat() + 'Z'
        
        if account.tags:
            item['tags'] = account.tags
        
        try:
            # Use condition expression to prevent overwriting existing items
            self.table.put_item(
                Item=item,
                ConditionExpression='attribute_not_exists(account_id)'
            )
            
            self.logger.info(
                'Onboarding request created successfully',
                account_id=account.account_id,
                status='pending'
            )
            
            return item
            
        except ClientError as e:
            if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
                self.logger.warning(
                    'Onboarding request already exists',
                    account_id=account.account_id
                )
                # Return existing item
                response = self.table.get_item(Key={'account_id': account.account_id})
                return response.get('Item', item)
            else:
                self.logger.error(
                    'Failed to create onboarding request',
                    account_id=account.account_id,
                    error_code=e.response['Error']['Code'],
                    error_message=e.response['Error']['Message']
                )
                raise
    
    def process_new_accounts(self) -> Dict[str, Any]:
        """
        Discover accounts and create onboarding requests for new ones.
        
        This is the main entry point for the discovery process.
        
        Returns:
            Dictionary with processing results
            
        Requirements: REQ-1.1, REQ-1.2, REQ-1.3, REQ-1.4
        """
        self.logger.info('Starting new account processing')
        
        results = {
            'total_discovered': 0,
            'new_accounts': 0,
            'existing_accounts': 0,
            'failed_accounts': 0,
            'accounts_created': []
        }
        
        try:
            # Discover all accounts
            accounts = self.discover_new_accounts()
            results['total_discovered'] = len(accounts)
            
            # Process each account
            for account in accounts:
                try:
                    # Check if already onboarded
                    if self.is_account_onboarded(account.account_id):
                        results['existing_accounts'] += 1
                        self.logger.debug(
                            'Skipping existing account',
                            account_id=account.account_id
                        )
                        continue
                    
                    # Create onboarding request
                    onboarding_request = self.create_onboarding_request(account)
                    results['new_accounts'] += 1
                    results['accounts_created'].append({
                        'account_id': account.account_id,
                        'account_name': account.account_name,
                        'status': 'pending'
                    })
                    
                except Exception as e:
                    results['failed_accounts'] += 1
                    self.logger.error(
                        'Failed to process account',
                        account_id=account.account_id,
                        error=str(e)
                    )
            
            self.logger.info(
                'Account processing completed',
                **results
            )
            
            return results
            
        except Exception as e:
            self.logger.error(
                'Account processing failed',
                error=str(e)
            )
            raise


def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Lambda handler for account discovery.
    
    Triggered by:
    - EventBridge scheduled rule (every 15 minutes)
    - EventBridge Organizations events (CreateAccountResult)
    - Manual invocation
    
    Args:
        event: Lambda event (EventBridge or manual)
        context: Lambda context
        
    Returns:
        Dictionary with processing results
    """
    # Get environment variables
    dynamodb_table_name = os.environ.get('ONBOARDING_STATE_TABLE')
    
    if not dynamodb_table_name:
        raise ValueError('ONBOARDING_STATE_TABLE environment variable not set')
    
    # Initialize logger
    logger = get_logger('account-discovery', event=event, lambda_context=context)
    
    logger.info(
        'Account discovery Lambda invoked',
        event_source=event.get('source', 'manual'),
        detail_type=event.get('detail-type', 'unknown')
    )
    
    try:
        # Initialize discovery service
        service = AccountDiscoveryService(
            dynamodb_table_name=dynamodb_table_name,
            correlation_id=logger.get_correlation_id(),
            logger=logger
        )
        
        # Process accounts
        results = service.process_new_accounts()
        
        logger.info('Account discovery completed successfully', **results)
        
        return {
            'statusCode': 200,
            'body': results
        }
        
    except Exception as e:
        logger.exception('Account discovery failed', error=str(e))
        
        return {
            'statusCode': 500,
            'body': {
                'error': str(e),
                'message': 'Account discovery failed'
            }
        }
