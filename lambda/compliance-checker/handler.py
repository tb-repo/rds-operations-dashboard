#!/usr/bin/env python3
"""
Compliance Checker Lambda Handler

Generated by: claude-3.5-sonnet
Timestamp: 2025-11-13T00:00:00Z
Version: 1.0.0
Policy Version: v1.0.0
Traceability: REQ-6.1, REQ-6.2, REQ-6.3, REQ-6.4, REQ-6.5 → DESIGN-001 → TASK-5
Review Status: Pending
Risk Level: Level 2

Purpose: Validate RDS instances against security and operational compliance standards.
Checks backups, encryption, patch levels, Multi-AZ, deletion protection, and pending maintenance.

Trigger: EventBridge scheduled rule (daily at 02:00 SGT)
"""

import json
import os
import sys
from datetime import datetime
from typing import Dict, List, Any

# Add parent directory to path for shared modules
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from shared.logger import get_logger
from shared.aws_clients import get_dynamodb_client, get_s3_client, get_sns_client
from shared.config import get_config

# Import compliance checker modules
from checks import ComplianceChecker
from reporting import ComplianceReporter

logger = get_logger(__name__)


def lambda_handler(event, context):
    """
    Main Lambda handler for compliance checking.
    
    Triggered daily at 02:00 SGT to validate RDS compliance.
    
    Args:
        event: EventBridge scheduled event
        context: Lambda context
        
    Returns:
        dict: Execution summary with compliance status
    """
    logger.info("Starting compliance check", extra={
        "event": event,
        "request_id": context.request_id
    })
    
    try:
        config = get_config()
        
        # Initialize components
        checker = ComplianceChecker(config)
        reporter = ComplianceReporter(config)
        
        # Step 1: Get RDS inventory
        logger.info("Retrieving RDS inventory")
        instances = get_rds_inventory()
        logger.info(f"Found {len(instances)} RDS instances to check")
        
        if not instances:
            logger.warning("No RDS instances found in inventory")
            return {
                "statusCode": 200,
                "message": "No instances to check",
                "total_instances": 0,
                "compliant_instances": 0,
                "violations": []
            }
        
        # Step 2: Run compliance checks on all instances
        logger.info("Running compliance checks")
        all_violations = []
        compliant_count = 0
        
        for instance in instances:
            try:
                violations = checker.check_instance_compliance(instance)
                
                if violations:
                    all_violations.extend(violations)
                    logger.warning(f"Found {len(violations)} violations for {instance['instance_id']}")
                else:
                    compliant_count += 1
                    logger.debug(f"Instance {instance['instance_id']} is compliant")
                    
            except Exception as e:
                logger.error(f"Failed to check compliance for {instance['instance_id']}: {str(e)}")
                continue
        
        logger.info(f"Compliance check complete: {compliant_count}/{len(instances)} compliant, {len(all_violations)} violations")
        
        # Step 3: Store compliance status in DynamoDB
        logger.info("Storing compliance status")
        store_compliance_status(instances, all_violations)
        
        # Step 4: Create alerts for violations
        logger.info("Creating compliance alerts")
        critical_violations = create_compliance_alerts(all_violations)
        
        # Step 5: Generate compliance report
        logger.info("Generating compliance report")
        report = reporter.generate_compliance_report(
            instances,
            all_violations,
            compliant_count
        )
        
        # Step 6: Save report to S3
        report_key = reporter.save_report_to_s3(report)
        logger.info(f"Compliance report saved to S3: {report_key}")
        
        # Step 7: Send SNS notification for critical violations
        if critical_violations:
            logger.info(f"Sending SNS notification for {len(critical_violations)} critical violations")
            send_critical_violation_notification(critical_violations)
        
        # Return summary
        result = {
            "statusCode": 200,
            "message": "Compliance check completed successfully",
            "total_instances": len(instances),
            "compliant_instances": compliant_count,
            "total_violations": len(all_violations),
            "critical_violations": len(critical_violations),
            "report_s3_key": report_key,
            "violations_by_severity": {
                "critical": len([v for v in all_violations if v['severity'] == 'Critical']),
                "high": len([v for v in all_violations if v['severity'] == 'High']),
                "medium": len([v for v in all_violations if v['severity'] == 'Medium']),
                "low": len([v for v in all_violations if v['severity'] == 'Low'])
            }
        }
        
        logger.info("Compliance check completed", extra=result)
        return result
        
    except Exception as e:
        logger.error(f"Compliance check failed: {str(e)}", exc_info=True)
        raise


def get_rds_inventory() -> List[Dict[str, Any]]:
    """
    Retrieve all RDS instances from DynamoDB inventory table.
    
    Returns:
        list: List of RDS instance records
    """
    config = get_config()
    dynamodb = get_dynamodb_client()
    table_name = config.get('dynamodb_tables', {}).get('rds_inventory', 'rds-inventory-prod')
    
    try:
        response = dynamodb.scan(
            TableName=table_name,
            FilterExpression='attribute_exists(instance_id) AND #status = :status',
            ExpressionAttributeNames={
                '#status': 'status'
            },
            ExpressionAttributeValues={
                ':status': {'S': 'available'}
            }
        )
        
        instances = []
        for item in response.get('Items', []):
            instances.append(deserialize_dynamodb_item(item))
        
        # Handle pagination
        while 'LastEvaluatedKey' in response:
            response = dynamodb.scan(
                TableName=table_name,
                FilterExpression='attribute_exists(instance_id) AND #status = :status',
                ExpressionAttributeNames={
                    '#status': 'status'
                },
                ExpressionAttributeValues={
                    ':status': {'S': 'available'}
                },
                ExclusiveStartKey=response['LastEvaluatedKey']
            )
            for item in response.get('Items', []):
                instances.append(deserialize_dynamodb_item(item))
        
        return instances
        
    except Exception as e:
        logger.error(f"Failed to retrieve RDS inventory: {str(e)}")
        raise


def store_compliance_status(
    instances: List[Dict[str, Any]],
    violations: List[Dict[str, Any]]
) -> None:
    """
    Store compliance status in DynamoDB.
    
    Args:
        instances: List of RDS instances
        violations: List of compliance violations
    """
    config = get_config()
    dynamodb = get_dynamodb_client()
    table_name = config.get('dynamodb_tables', {}).get('rds_inventory', 'rds-inventory-prod')
    
    # Create violation lookup by instance
    violations_by_instance = {}
    for violation in violations:
        instance_id = violation['instance_id']
        if instance_id not in violations_by_instance:
            violations_by_instance[instance_id] = []
        violations_by_instance[instance_id].append(violation)
    
    # Update each instance with compliance status
    for instance in instances:
        instance_id = instance['instance_id']
        instance_violations = violations_by_instance.get(instance_id, [])
        
        compliance_status = {
            'is_compliant': len(instance_violations) == 0,
            'violation_count': len(instance_violations),
            'last_checked': datetime.utcnow().isoformat() + 'Z',
            'critical_violations': len([v for v in instance_violations if v['severity'] == 'Critical']),
            'high_violations': len([v for v in instance_violations if v['severity'] == 'High'])
        }
        
        try:
            dynamodb.update_item(
                TableName=table_name,
                Key={'instance_id': {'S': instance_id}},
                UpdateExpression='SET compliance_status = :status',
                ExpressionAttributeValues={
                    ':status': {'M': serialize_dynamodb_value(compliance_status)}
                }
            )
        except Exception as e:
            logger.error(f"Failed to update compliance status for {instance_id}: {str(e)}")


def create_compliance_alerts(violations: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Create alerts for compliance violations in health_alerts table.
    
    Args:
        violations: List of compliance violations
        
    Returns:
        list: List of critical violations
    """
    config = get_config()
    dynamodb = get_dynamodb_client()
    table_name = config.get('dynamodb_tables', {}).get('health_alerts', 'health-alerts-prod')
    
    critical_violations = []
    
    for violation in violations:
        # Only create alerts for Critical and High severity
        if violation['severity'] not in ['Critical', 'High']:
            continue
        
        if violation['severity'] == 'Critical':
            critical_violations.append(violation)
        
        alert_id = f"compliance-{violation['instance_id']}-{violation['check_type']}-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
        created_at = datetime.utcnow().isoformat() + 'Z'
        
        alert = {
            'alert_id': alert_id,
            'instance_id': violation['instance_id'],
            'alert_type': 'compliance',
            'severity': violation['severity'].lower(),
            'check_type': violation['check_type'],
            'message': violation['message'],
            'remediation': violation.get('remediation', ''),
            'status': 'active',
            'created_at': created_at,
            'acknowledged_at': None,
            'acknowledged_by': None,
            'resolved_at': None,
            'notification_sent': False
        }
        
        try:
            dynamodb.put_item(
                TableName=table_name,
                Item=serialize_dynamodb_item(alert)
            )
        except Exception as e:
            logger.error(f"Failed to create alert for {violation['instance_id']}: {str(e)}")
    
    return critical_violations


def send_critical_violation_notification(violations: List[Dict[str, Any]]) -> None:
    """
    Send SNS notification for critical compliance violations.
    
    Args:
        violations: List of critical violations
    """
    config = get_config()
    sns = get_sns_client()
    topic_arn = config.get('sns_topic_arn')
    
    if not topic_arn:
        logger.warning("SNS topic ARN not configured, skipping notification")
        return
    
    # Group violations by instance
    violations_by_instance = {}
    for violation in violations:
        instance_id = violation['instance_id']
        if instance_id not in violations_by_instance:
            violations_by_instance[instance_id] = []
        violations_by_instance[instance_id].append(violation)
    
    # Create notification message
    subject = f"[CRITICAL] RDS Compliance Violations Detected - {len(violations)} issues"
    
    message_lines = [
        "RDS Compliance Check - Critical Violations Detected",
        "=" * 60,
        f"Total Critical Violations: {len(violations)}",
        f"Affected Instances: {len(violations_by_instance)}",
        f"Check Date: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC",
        "",
        "Violations by Instance:",
        ""
    ]
    
    for instance_id, instance_violations in violations_by_instance.items():
        message_lines.append(f"Instance: {instance_id}")
        for violation in instance_violations:
            message_lines.append(f"  - {violation['check_type']}: {violation['message']}")
            if violation.get('remediation'):
                message_lines.append(f"    Remediation: {violation['remediation']}")
        message_lines.append("")
    
    message_lines.extend([
        "=" * 60,
        "Please review the full compliance report in S3 for details.",
        "Dashboard: https://rds-dashboard.example.com/compliance"
    ])
    
    message = "\n".join(message_lines)
    
    try:
        sns.publish(
            TopicArn=topic_arn,
            Subject=subject,
            Message=message
        )
        logger.info(f"Sent SNS notification for {len(violations)} critical violations")
    except Exception as e:
        logger.error(f"Failed to send SNS notification: {str(e)}")


def serialize_dynamodb_item(data: Dict[str, Any]) -> Dict[str, Any]:
    """Convert Python dict to DynamoDB item format."""
    from boto3.dynamodb.types import TypeSerializer
    serializer = TypeSerializer()
    return {k: serializer.serialize(v) for k, v in data.items()}


def serialize_dynamodb_value(value: Any) -> Dict[str, Any]:
    """Convert Python value to DynamoDB format."""
    from boto3.dynamodb.types import TypeSerializer
    serializer = TypeSerializer()
    return serializer.serialize(value)


def deserialize_dynamodb_item(item: Dict[str, Any]) -> Dict[str, Any]:
    """Convert DynamoDB item to Python dict."""
    from boto3.dynamodb.types import TypeDeserializer
    deserializer = TypeDeserializer()
    return {k: deserializer.deserialize(v) for k, v in item.items()}


if __name__ == '__main__':
    # For local testing
    class MockContext:
        request_id = 'local-test'
    
    result = lambda_handler({}, MockContext())
    print(json.dumps(result, indent=2))
