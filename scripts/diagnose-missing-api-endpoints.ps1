#!/usr/bin/env pwsh

<#
.SYNOPSIS
    Diagnose Missing API Endpoints - Comprehensive Analysis
    
.DESCRIPTION
    This script diagnoses the root causes of 500 Internal Server Error failures
    on critical API endpoints: /api/instances, /api/compliance, and /api/costs.
    
    Generated by: claude-3.5-sonnet
    Feature: missing-api-endpoints-fix
    Task: 1. Diagnose current API endpoint failures
    Requirements: 1.1, 2.1, 3.1, 4.1
    
.PARAMETER Region
    AWS region to check (default: ap-southeast-1)
    
.PARAMETER Verbose
    Enable verbose output for detailed diagnostics
#>

param(
    [string]$Region = "ap-southeast-1",
    [switch]$Verbose
)

# Set error action preference
$ErrorActionPreference = "Continue"

Write-Host "=== Missing API Endpoints Diagnostic Report ===" -ForegroundColor Cyan
Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Gray
Write-Host "Region: $Region" -ForegroundColor Gray
Write-Host ""

# Initialize diagnostic results
$DiagnosticResults = @{
    BFFStatus = @{}
    APIGatewayStatus = @{}
    LambdaFunctions = @{}
    DynamoDBTables = @{}
    Issues = @()
    Recommendations = @()
}

function Write-DiagnosticSection {
    param([string]$Title)
    Write-Host "--- $Title ---" -ForegroundColor Yellow
}

function Write-Success {
    param([string]$Message)
    Write-Host "✅ $Message" -ForegroundColor Green
}

function Write-Warning {
    param([string]$Message)
    Write-Host "⚠️  $Message" -ForegroundColor Yellow
    $DiagnosticResults.Issues += "WARNING: $Message"
}

function Write-Error {
    param([string]$Message)
    Write-Host "❌ $Message" -ForegroundColor Red
    $DiagnosticResults.Issues += "ERROR: $Message"
}

function Write-Info {
    param([string]$Message)
    if ($Verbose) {
        Write-Host "ℹ️  $Message" -ForegroundColor Cyan
    }
}

# 1. Check BFF Configuration and Status
Write-DiagnosticSection "BFF Layer Analysis"

try {
    # Check if BFF is deployed
    $bffFunctions = aws lambda list-functions --region $Region --query "Functions[?contains(FunctionName, 'bff') || contains(FunctionName, 'BFF')]" --output json 2>$null
    
    if ($bffFunctions) {
        $bffData = $bffFunctions | ConvertFrom-Json
        if ($bffData.Count -gt 0) {
            Write-Success "BFF Lambda function found: $($bffData[0].FunctionName)"
            $DiagnosticResults.BFFStatus.Deployed = $true
            $DiagnosticResults.BFFStatus.FunctionName = $bffData[0].FunctionName
            $DiagnosticResults.BFFStatus.Runtime = $bffData[0].Runtime
            $DiagnosticResults.BFFStatus.LastModified = $bffData[0].LastModified
            
            # Check BFF environment variables
            $envVars = aws lambda get-function-configuration --function-name $bffData[0].FunctionName --region $Region --query "Environment.Variables" --output json 2>$null
            if ($envVars) {
                $envData = $envVars | ConvertFrom-Json
                $DiagnosticResults.BFFStatus.EnvironmentVariables = $envData
                
                # Check critical environment variables
                $requiredEnvVars = @("INTERNAL_API_URL", "COGNITO_USER_POOL_ID", "COGNITO_REGION")
                foreach ($envVar in $requiredEnvVars) {
                    if ($envData.$envVar) {
                        Write-Success "BFF has required environment variable: $envVar"
                    } else {
                        Write-Error "BFF missing required environment variable: $envVar"
                    }
                }
                
                # Check INTERNAL_API_URL configuration
                if ($envData.INTERNAL_API_URL) {
                    Write-Info "BFF INTERNAL_API_URL: $($envData.INTERNAL_API_URL)"
                    $DiagnosticResults.BFFStatus.InternalApiUrl = $envData.INTERNAL_API_URL
                }
            }
        } else {
            Write-Error "No BFF Lambda function found"
            $DiagnosticResults.BFFStatus.Deployed = $false
        }
    } else {
        Write-Error "Failed to query Lambda functions or no BFF found"
        $DiagnosticResults.BFFStatus.Deployed = $false
    }
} catch {
    Write-Error "Failed to check BFF status: $($_.Exception.Message)"
    $DiagnosticResults.BFFStatus.Error = $_.Exception.Message
}

# 2. Check API Gateway Configuration
Write-DiagnosticSection "API Gateway Analysis"

try {
    # List API Gateways
    $apis = aws apigateway get-rest-apis --region $Region --query "items[?contains(name, 'rds') || contains(name, 'dashboard')]" --output json 2>$null
    
    if ($apis) {
        $apiData = $apis | ConvertFrom-Json
        if ($apiData.Count -gt 0) {
            foreach ($api in $apiData) {
                Write-Success "Found API Gateway: $($api.name) (ID: $($api.id))"
                $DiagnosticResults.APIGatewayStatus[$api.name] = @{
                    Id = $api.id
                    Name = $api.name
                    CreatedDate = $api.createdDate
                    Routes = @{}
                }
                
                # Check specific routes
                $routes = aws apigateway get-resources --rest-api-id $api.id --region $Region --output json 2>$null
                if ($routes) {
                    $routeData = $routes | ConvertFrom-Json
                    $criticalPaths = @("instances", "compliance", "costs")
                    
                    foreach ($path in $criticalPaths) {
                        $foundRoute = $routeData.items | Where-Object { $_.pathPart -eq $path -or $_.path -like "*/$path" }
                        if ($foundRoute) {
                            Write-Success "Found route for /$path"
                            $DiagnosticResults.APIGatewayStatus[$api.name].Routes[$path] = @{
                                Found = $true
                                ResourceId = $foundRoute.id
                                Path = $foundRoute.path
                            }
                            
                            # Check if route has Lambda integration
                            try {
                                $methods = aws apigateway get-resource --rest-api-id $api.id --resource-id $foundRoute.id --region $Region --output json 2>$null
                                if ($methods) {
                                    $methodData = $methods | ConvertFrom-Json
                                    if ($methodData.resourceMethods.GET) {
                                        $integration = aws apigateway get-integration --rest-api-id $api.id --resource-id $foundRoute.id --http-method GET --region $Region --output json 2>$null
                                        if ($integration) {
                                            $integrationData = $integration | ConvertFrom-Json
                                            if ($integrationData.type -eq "AWS_PROXY" -and $integrationData.uri -like "*lambda*") {
                                                Write-Success "Route /$path has Lambda integration"
                                                $DiagnosticResults.APIGatewayStatus[$api.name].Routes[$path].HasLambdaIntegration = $true
                                                $DiagnosticResults.APIGatewayStatus[$api.name].Routes[$path].IntegrationUri = $integrationData.uri
                                            } else {
                                                Write-Warning "Route /$path has non-Lambda integration: $($integrationData.type)"
                                                $DiagnosticResults.APIGatewayStatus[$api.name].Routes[$path].HasLambdaIntegration = $false
                                            }
                                        }
                                    } else {
                                        Write-Warning "Route /$path missing GET method"
                                    }
                                }
                            } catch {
                                Write-Warning "Could not check integration for /$path`: $($_.Exception.Message)"
                            }
                        } else {
                            Write-Error "Missing route for /$path"
                            $DiagnosticResults.APIGatewayStatus[$api.name].Routes[$path] = @{
                                Found = $false
                            }
                        }
                    }
                }
            }
        } else {
            Write-Error "No API Gateway found for RDS Dashboard"
        }
    }
} catch {
    Write-Error "Failed to check API Gateway: $($_.Exception.Message)"
    $DiagnosticResults.APIGatewayStatus.Error = $_.Exception.Message
}

# 3. Check Lambda Functions for Backend Endpoints
Write-DiagnosticSection "Backend Lambda Functions Analysis"

$expectedLambdas = @{
    "query-handler" = @("instances", "compliance", "costs")
    "compliance-checker" = @("compliance")
    "cost-analyzer" = @("costs")
    "monitoring" = @("instances", "metrics")
}

try {
    $allLambdas = aws lambda list-functions --region $Region --output json 2>$null
    if ($allLambdas) {
        $lambdaData = $allLambdas | ConvertFrom-Json
        
        foreach ($expectedLambda in $expectedLambdas.Keys) {
            $foundLambda = $lambdaData.Functions | Where-Object { $_.FunctionName -like "*$expectedLambda*" }
            
            if ($foundLambda) {
                Write-Success "Found Lambda function: $($foundLambda.FunctionName)"
                $DiagnosticResults.LambdaFunctions[$expectedLambda] = @{
                    Found = $true
                    FunctionName = $foundLambda.FunctionName
                    Runtime = $foundLambda.Runtime
                    LastModified = $foundLambda.LastModified
                    State = $foundLambda.State
                    CodeSize = $foundLambda.CodeSize
                }
                
                # Check function configuration
                try {
                    $config = aws lambda get-function-configuration --function-name $foundLambda.FunctionName --region $Region --output json 2>$null
                    if ($config) {
                        $configData = $config | ConvertFrom-Json
                        $DiagnosticResults.LambdaFunctions[$expectedLambda].Environment = $configData.Environment.Variables
                        
                        # Check if function is active
                        if ($configData.State -eq "Active") {
                            Write-Success "Lambda $expectedLambda is Active"
                        } else {
                            Write-Warning "Lambda $expectedLambda state: $($configData.State)"
                        }
                    }
                } catch {
                    Write-Warning "Could not get configuration for $expectedLambda`: $($_.Exception.Message)"
                }
                
                # Test function invocation
                try {
                    Write-Info "Testing Lambda function: $($foundLambda.FunctionName)"
                    $testPayload = '{"httpMethod":"GET","path":"/health","headers":{}}'
                    $testResult = aws lambda invoke --function-name $foundLambda.FunctionName --payload $testPayload --region $Region response.json 2>$null
                    
                    if (Test-Path "response.json") {
                        $response = Get-Content "response.json" | ConvertFrom-Json
                        if ($response.statusCode -eq 200 -or $response.statusCode -eq 404) {
                            Write-Success "Lambda $expectedLambda responds to test invocation"
                            $DiagnosticResults.LambdaFunctions[$expectedLambda].TestInvocation = "Success"
                        } else {
                            Write-Warning "Lambda $expectedLambda returned status: $($response.statusCode)"
                            $DiagnosticResults.LambdaFunctions[$expectedLambda].TestInvocation = "Warning - Status: $($response.statusCode)"
                        }
                        Remove-Item "response.json" -Force -ErrorAction SilentlyContinue
                    }
                } catch {
                    Write-Warning "Could not test invoke $expectedLambda`: $($_.Exception.Message)"
                    $DiagnosticResults.LambdaFunctions[$expectedLambda].TestInvocation = "Failed: $($_.Exception.Message)"
                }
            } else {
                Write-Error "Missing Lambda function: $expectedLambda"
                $DiagnosticResults.LambdaFunctions[$expectedLambda] = @{
                    Found = $false
                }
                $DiagnosticResults.Recommendations += "Deploy missing Lambda function: $expectedLambda"
            }
        }
    }
} catch {
    Write-Error "Failed to check Lambda functions: $($_.Exception.Message)"
    $DiagnosticResults.LambdaFunctions.Error = $_.Exception.Message
}

# 4. Check DynamoDB Tables
Write-DiagnosticSection "DynamoDB Tables Analysis"

$expectedTables = @(
    "rds-inventory-prod",
    "cost-snapshots-prod", 
    "rds_compliance",
    "health-alerts-prod",
    "metrics-cache-prod"
)

try {
    foreach ($tableName in $expectedTables) {
        try {
            $tableInfo = aws dynamodb describe-table --table-name $tableName --region $Region --output json 2>$null
            if ($tableInfo) {
                $tableData = $tableInfo | ConvertFrom-Json
                Write-Success "Found DynamoDB table: $tableName"
                $DiagnosticResults.DynamoDBTables[$tableName] = @{
                    Found = $true
                    Status = $tableData.Table.TableStatus
                    ItemCount = $tableData.Table.ItemCount
                    CreationDateTime = $tableData.Table.CreationDateTime
                }
                
                if ($tableData.Table.TableStatus -eq "ACTIVE") {
                    Write-Success "Table $tableName is ACTIVE"
                } else {
                    Write-Warning "Table $tableName status: $($tableData.Table.TableStatus)"
                }
            } else {
                Write-Error "DynamoDB table not found: $tableName"
                $DiagnosticResults.DynamoDBTables[$tableName] = @{
                    Found = $false
                }
                $DiagnosticResults.Recommendations += "Create missing DynamoDB table: $tableName"
            }
        } catch {
            Write-Error "Could not check table $tableName`: $($_.Exception.Message)"
            $DiagnosticResults.DynamoDBTables[$tableName] = @{
                Found = $false
                Error = $_.Exception.Message
            }
        }
    }
} catch {
    Write-Error "Failed to check DynamoDB tables: $($_.Exception.Message)"
}

# 5. Test API Endpoints Directly
Write-DiagnosticSection "Direct API Endpoint Testing"

if ($DiagnosticResults.BFFStatus.InternalApiUrl) {
    $baseUrl = $DiagnosticResults.BFFStatus.InternalApiUrl
    $testEndpoints = @("instances", "compliance", "costs")
    
    foreach ($endpoint in $testEndpoints) {
        try {
            Write-Info "Testing endpoint: $baseUrl/$endpoint"
            $response = Invoke-WebRequest -Uri "$baseUrl/$endpoint" -Method GET -Headers @{"x-api-key" = "test"} -TimeoutSec 10 -ErrorAction Stop
            Write-Success "Endpoint /$endpoint returned status: $($response.StatusCode)"
            $DiagnosticResults.APIGatewayStatus.EndpointTests = @{} if (-not $DiagnosticResults.APIGatewayStatus.EndpointTests)
            $DiagnosticResults.APIGatewayStatus.EndpointTests[$endpoint] = @{
                StatusCode = $response.StatusCode
                Success = $true
            }
        } catch {
            $statusCode = if ($_.Exception.Response) { $_.Exception.Response.StatusCode } else { "Unknown" }
            Write-Error "Endpoint /$endpoint failed with status: $statusCode - $($_.Exception.Message)"
            $DiagnosticResults.APIGatewayStatus.EndpointTests = @{} if (-not $DiagnosticResults.APIGatewayStatus.EndpointTests)
            $DiagnosticResults.APIGatewayStatus.EndpointTests[$endpoint] = @{
                StatusCode = $statusCode
                Success = $false
                Error = $_.Exception.Message
            }
        }
    }
}

# 6. Generate Summary and Recommendations
Write-DiagnosticSection "Diagnostic Summary"

Write-Host ""
Write-Host "=== ISSUES IDENTIFIED ===" -ForegroundColor Red
if ($DiagnosticResults.Issues.Count -eq 0) {
    Write-Host "No critical issues found." -ForegroundColor Green
} else {
    foreach ($issue in $DiagnosticResults.Issues) {
        Write-Host "• $issue" -ForegroundColor Red
    }
}

Write-Host ""
Write-Host "=== RECOMMENDATIONS ===" -ForegroundColor Yellow
if ($DiagnosticResults.Recommendations.Count -eq 0) {
    Write-Host "No specific recommendations at this time." -ForegroundColor Green
} else {
    foreach ($recommendation in $DiagnosticResults.Recommendations) {
        Write-Host "• $recommendation" -ForegroundColor Yellow
    }
}

# Additional analysis-based recommendations
if (-not $DiagnosticResults.LambdaFunctions["query-handler"].Found) {
    $DiagnosticResults.Recommendations += "Deploy Query Handler Lambda function to handle /instances, /compliance, and /costs endpoints"
}

if (-not $DiagnosticResults.LambdaFunctions["compliance-checker"].Found) {
    $DiagnosticResults.Recommendations += "Deploy Compliance Checker Lambda function for compliance data"
}

if (-not $DiagnosticResults.LambdaFunctions["cost-analyzer"].Found) {
    $DiagnosticResults.Recommendations += "Deploy Cost Analyzer Lambda function for cost data"
}

# Check for API Gateway to Lambda integration issues
foreach ($api in $DiagnosticResults.APIGatewayStatus.Keys) {
    if ($api -ne "EndpointTests" -and $api -ne "Error") {
        $apiData = $DiagnosticResults.APIGatewayStatus[$api]
        foreach ($route in @("instances", "compliance", "costs")) {
            if ($apiData.Routes[$route] -and -not $apiData.Routes[$route].HasLambdaIntegration) {
                $DiagnosticResults.Recommendations += "Configure Lambda integration for API Gateway route: /$route"
            }
        }
    }
}

Write-Host ""
Write-Host "=== ROOT CAUSE ANALYSIS ===" -ForegroundColor Magenta

# Determine most likely root causes
$rootCauses = @()

if (-not $DiagnosticResults.LambdaFunctions["query-handler"].Found) {
    $rootCauses += "CRITICAL: Query Handler Lambda function is missing - this handles /instances, /compliance, and /costs endpoints"
}

if ($DiagnosticResults.APIGatewayStatus.EndpointTests) {
    $failedEndpoints = $DiagnosticResults.APIGatewayStatus.EndpointTests.Keys | Where-Object { 
        -not $DiagnosticResults.APIGatewayStatus.EndpointTests[$_].Success 
    }
    if ($failedEndpoints.Count -gt 0) {
        $rootCauses += "API endpoints are returning errors: $($failedEndpoints -join ', ')"
    }
}

$missingTables = $DiagnosticResults.DynamoDBTables.Keys | Where-Object { 
    -not $DiagnosticResults.DynamoDBTables[$_].Found 
}
if ($missingTables.Count -gt 0) {
    $rootCauses += "Missing DynamoDB tables may cause Lambda functions to fail: $($missingTables -join ', ')"
}

if ($rootCauses.Count -eq 0) {
    Write-Host "No clear root cause identified. Further investigation needed." -ForegroundColor Yellow
} else {
    foreach ($cause in $rootCauses) {
        Write-Host "• $cause" -ForegroundColor Red
    }
}

# 7. Save diagnostic results to file
Write-DiagnosticSection "Saving Results"

$timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
$outputFile = "diagnostic-results-$timestamp.json"

try {
    $DiagnosticResults | ConvertTo-Json -Depth 10 | Out-File -FilePath $outputFile -Encoding UTF8
    Write-Success "Diagnostic results saved to: $outputFile"
} catch {
    Write-Warning "Could not save diagnostic results: $($_.Exception.Message)"
}

Write-Host ""
Write-Host "=== DIAGNOSTIC COMPLETE ===" -ForegroundColor Cyan
Write-Host "Next Steps:" -ForegroundColor White
Write-Host "1. Review the issues and recommendations above" -ForegroundColor Gray
Write-Host "2. Deploy missing Lambda functions" -ForegroundColor Gray
Write-Host "3. Configure API Gateway integrations" -ForegroundColor Gray
Write-Host "4. Create missing DynamoDB tables" -ForegroundColor Gray
Write-Host "5. Test endpoints after fixes" -ForegroundColor Gray

# Return exit code based on critical issues
if ($DiagnosticResults.Issues | Where-Object { $_ -like "*ERROR*" }) {
    exit 1
} else {
    exit 0
}